<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>9.1 Polar Coordinates — Precalculus</title>
  <link rel="stylesheet" href="../css/styles.css" />
</head>
<body>

  <header class="lesson-header">
    <a class="back-link" href="../index.html">← Back to all lessons</a>
    <p class="section-tag">Section 9.1</p>
    <h1>Polar Coordinates</h1>
    <p>A new way to describe every point in the plane</p>
  </header>

  <main class="lesson-body">

    <!-- CONCEPT -->
    <div class="block">
      <h2>What Are Polar Coordinates?</h2>
      <p>
        You already know how to locate a point using <strong>(x, y)</strong> — the rectangular
        (Cartesian) system. Polar coordinates give you a second way to describe the exact same point,
        using <strong>distance</strong> and <strong>direction</strong> instead.
      </p>
      <p>
        A polar coordinate is written as <strong>(r, θ)</strong> where:
      </p>
      <div class="formula-box">
        <strong>r</strong> = the distance from the origin (the "pole") to the point<br>
        <strong>θ</strong> = the angle measured counterclockwise from the positive x-axis (the "polar axis")<br><br>
        θ can be in <strong>degrees</strong> or <strong>radians</strong>
      </div>
      <p>
        Think of it like giving directions: instead of saying "go 3 right and 4 up," you say
        "go 5 units at a 53° angle."
      </p>
      <h3>Important Notes</h3>
      <p>
        Unlike rectangular coordinates, a polar point has <strong>infinitely many representations</strong>
        because you can add or subtract full rotations (360° or 2π) to θ and reach the same point.
        Also, a <strong>negative r</strong> means you go in the opposite direction of θ.
      </p>
      <div class="formula-box">
        (r, θ) = (r, θ + 360°) = (r, θ + 720°) = … <br>
        (r, θ) = (−r, θ + 180°)
      </div>
    </div>

    <!-- CONVERSION FORMULAS -->
    <div class="block">
      <h2>Converting Between Polar and Rectangular</h2>
      <p>These four formulas connect the two systems. Memorize them — you'll use them constantly.</p>

      <h3>Polar → Rectangular</h3>
      <div class="formula-box">
        x = r · cos(θ)<br>
        y = r · sin(θ)
      </div>

      <h3>Rectangular → Polar</h3>
      <div class="formula-box">
        r = √(x² + y²)<br>
        tan(θ) = y / x &nbsp;&nbsp; ← then use arctan, and adjust for the correct quadrant
      </div>

      <div class="example-box">
        <p class="ex-label">Example 1 — Polar to Rectangular</p>
        <p>Convert (4, 60°) to rectangular form.</p>
        <p>
          x = 4 · cos(60°) = 4 · (1/2) = <strong>2</strong><br>
          y = 4 · sin(60°) = 4 · (√3/2) = <strong>2√3 ≈ 3.46</strong>
        </p>
        <p>Rectangular form: <strong>(2, 2√3)</strong></p>
      </div>

      <div class="example-box">
        <p class="ex-label">Example 2 — Rectangular to Polar</p>
        <p>Convert (−3, 3) to polar form.</p>
        <p>
          r = √((−3)² + 3²) = √(9 + 9) = √18 = <strong>3√2</strong><br>
          tan(θ) = 3 / (−3) = −1 → arctan(−1) = −45°<br>
          But (−3, 3) is in <strong>Quadrant II</strong>, so θ = 180° − 45° = <strong>135°</strong>
        </p>
        <p>Polar form: <strong>(3√2, 135°)</strong></p>
      </div>
    </div>

    <!-- INTERACTIVE PLOTTER -->
    <div class="block">
      <h2>Interactive Polar Plotter</h2>
      <p>Enter any polar point (r, θ) below and see it plotted on the polar coordinate system.
         The equivalent rectangular coordinates are shown automatically.</p>

      <div class="interactive-box">
        <h3>Plot a Polar Point</h3>

        <!-- DEG / RAD toggle -->
        <div class="mode-toggle">
          <button id="btn-deg" class="mode-btn active" onclick="setMode('deg')">DEG</button>
          <button id="btn-rad" class="mode-btn"        onclick="setMode('rad')">RAD</button>
        </div>

        <canvas id="polarCanvas" width="340" height="340"></canvas>

        <div class="input-row">
          <div class="input-group">
            <label>r (radius)</label>
            <input type="number" id="inputR" value="4" step="0.5" />
          </div>
          <div class="input-group">
            <label id="theta-label">θ (degrees)</label>
            <input type="number" id="inputThetaDeg" value="45" step="5" />
            <input type="text"   id="inputThetaRad" value="π/4" style="display:none;" placeholder="e.g. pi/4 or 3pi/2" />
          </div>
        </div>

        <!-- π quick-select buttons (shown in RAD mode only) -->
        <div id="pi-buttons" style="display:none; text-align:center;">
          <p style="font-size:0.78rem; color:#6b7a99; margin-bottom:8px; font-family:Arial,sans-serif;">Common angles — click to fill:</p>
          <div class="pi-btn-row">
            <button class="pi-btn" onclick="setPi('π/6')">π/6</button>
            <button class="pi-btn" onclick="setPi('π/4')">π/4</button>
            <button class="pi-btn" onclick="setPi('π/3')">π/3</button>
            <button class="pi-btn" onclick="setPi('π/2')">π/2</button>
            <button class="pi-btn" onclick="setPi('2π/3')">2π/3</button>
            <button class="pi-btn" onclick="setPi('3π/4')">3π/4</button>
          </div>
          <div class="pi-btn-row" style="margin-top:6px;">
            <button class="pi-btn" onclick="setPi('π')">π</button>
            <button class="pi-btn" onclick="setPi('5π/4')">5π/4</button>
            <button class="pi-btn" onclick="setPi('3π/2')">3π/2</button>
            <button class="pi-btn" onclick="setPi('7π/4')">7π/4</button>
            <button class="pi-btn" onclick="setPi('2π')">2π</button>
          </div>
        </div>

        <button class="plot-btn" onclick="plotPoint()">Plot Point</button>

        <div class="result-box" id="resultBox">
          Enter r and θ, then click Plot Point.
        </div>
      </div>
    </div>

    <!-- QUADRANT TIPS -->
    <div class="block">
      <h2>Quadrant Guide for Rectangular → Polar</h2>
      <p>When finding θ using arctan(y/x), you must check the quadrant of (x, y) and adjust:</p>
      <div class="formula-box">
        Quadrant I &nbsp; (x > 0, y > 0): θ = arctan(y/x) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ← no adjustment needed<br>
        Quadrant II &nbsp;(x &lt; 0, y > 0): θ = arctan(y/x) + 180°<br>
        Quadrant III (x &lt; 0, y &lt; 0): θ = arctan(y/x) + 180°<br>
        Quadrant IV &nbsp;(x > 0, y &lt; 0): θ = arctan(y/x) + 360°
      </div>
      <p>Your calculator's arctan always returns a value between −90° and 90°, so you need to
         adjust based on where the point actually lives.</p>
    </div>

    <!-- PRACTICE -->
    <div class="block">
      <h2>Practice Problems</h2>
      <p>Try each one on your own, then reveal the answer to check your work.</p>

      <div class="practice-problem">
        <p class="q-label">Problem 1</p>
        <p>Plot and convert to rectangular: <strong>(5, 30°)</strong></p>
        <button class="show-answer-btn" onclick="toggleAnswer('a1', this)">Show Answer</button>
        <div class="answer-reveal" id="a1">
          To convert polar → rectangular, use <strong>x = r·cos(θ)</strong> and <strong>y = r·sin(θ)</strong>.<br>
          Plug in r = 5 and θ = 30°:<br><br>
          x = 5 · cos(30°) = 5 · (√3/2) ≈ <strong>4.33</strong><br>
          y = 5 · sin(30°) = 5 · (1/2) = <strong>2.5</strong><br><br>
          cos(30°) = √3/2 and sin(30°) are values from the unit circle — worth memorizing!<br><br>
          <strong>Rectangular: (5√3/2, 5/2) ≈ (4.33, 2.5)</strong>
        </div>
      </div>

      <div class="practice-problem">
        <p class="q-label">Problem 2</p>
        <p>Convert to rectangular: <strong>(−3, 90°)</strong> &nbsp;(Note the negative r!)</p>
        <button class="show-answer-btn" onclick="toggleAnswer('a2', this)">Show Answer</button>
        <div class="answer-reveal" id="a2">
          The formulas x = r·cos(θ) and y = r·sin(θ) work even when r is negative — just substitute directly:<br><br>
          x = −3 · cos(90°) = −3 · 0 = <strong>0</strong><br>
          y = −3 · sin(90°) = −3 · 1 = <strong>−3</strong><br><br>
          <strong>Rectangular: (0, −3)</strong><br><br>
          Why does the negative r flip the point? Normally (3, 90°) points straight up to (0, 3).
          A negative r reverses that direction — so instead of going 3 units up, you go 3 units down, landing at (0, −3).
        </div>
      </div>

      <div class="practice-problem">
        <p class="q-label">Problem 3</p>
        <p>Convert to polar: <strong>(1, −√3)</strong></p>
        <button class="show-answer-btn" onclick="toggleAnswer('a3', this)">Show Answer</button>
        <div class="answer-reveal" id="a3">
          <strong>Step 1 — Find r</strong> using the distance formula r = √(x² + y²):<br>
          r = √(1² + (−√3)²) = √(1 + 3) = √4 = <strong>2</strong><br><br>
          <strong>Step 2 — Find θ</strong> using tan(θ) = y/x, then take arctan:<br>
          tan(θ) = −√3 / 1 = −√3 → arctan(−√3) = −60°<br><br>
          <strong>Step 3 — Check the quadrant!</strong> Your calculator's arctan only returns values between −90° and 90°, so it can give you the wrong angle. Always verify:<br>
          x = 1 > 0 and y = −√3 &lt; 0 → the point is in <strong>Quadrant IV</strong><br>
          In Q IV, the angle should be between 270° and 360°. Since arctan gave −60°, add 360°:<br>
          θ = −60° + 360° = <strong>300°</strong> ✓<br><br>
          <strong>Polar: (2, 300°)</strong>
        </div>
      </div>

      <div class="practice-problem">
        <p class="q-label">Problem 4</p>
        <p>Give two other polar representations of the point <strong>(3, 45°)</strong> — one with positive r and one with negative r.</p>
        <button class="show-answer-btn" onclick="toggleAnswer('a4', this)">Show Answer</button>
        <div class="answer-reveal" id="a4">
          There are two rules for writing the same point in a different way:<br><br>
          <strong>Rule 1 — Add any multiple of 360°</strong> to θ (keeping r positive).<br>
          A full rotation brings you right back to the same direction:<br>
          (3, 45° + 360°) = <strong>(3, 405°)</strong><br><br>
          <strong>Rule 2 — Negate r and add 180°</strong> to θ.<br>
          Flipping r reverses your direction, and adding 180° rotates you halfway around to compensate — so you end up at the same spot:<br>
          (−3, 45° + 180°) = <strong>(−3, 225°)</strong><br><br>
          All three — (3, 45°), (3, 405°), and (−3, 225°) — name the exact same point.
        </div>
      </div>

      <!-- Generated problems land here -->
      <div id="generated-problems"></div>

      <!-- Generate button -->
      <div style="text-align:center; margin-top:24px; padding-top:20px; border-top:1px solid var(--border);">
        <p id="gen-counter" style="font-size:0.82rem; color:#8a6a52; font-family:Arial,sans-serif; margin-bottom:10px;"></p>
        <button id="gen-btn" class="plot-btn" onclick="generateMore()">Generate 5 More Problems</button>
      </div>

    </div>

  </main>

  <script>
    // ── Canvas Setup ──
    const canvas = document.getElementById('polarCanvas');
    const ctx    = canvas.getContext('2d');
    const cx     = canvas.width  / 2;
    const cy     = canvas.height / 2;
    const scale  = 30;
    const rings  = 5;

    let currentMode = 'deg'; // 'deg' or 'rad'

    // Radian angle labels for the grid (every 30° = π/6)
    const radLabels = {
      0: '0', 30: 'π/6', 60: 'π/3', 90: 'π/2',
      120: '2π/3', 150: '5π/6', 180: 'π',
      210: '7π/6', 240: '4π/3', 270: '3π/2',
      300: '5π/3', 330: '11π/6'
    };

    // ── Mode Toggle ──
    function setMode(mode) {
      currentMode = mode;
      const isDeg = mode === 'deg';

      document.getElementById('btn-deg').classList.toggle('active', isDeg);
      document.getElementById('btn-rad').classList.toggle('active', !isDeg);
      document.getElementById('theta-label').textContent = isDeg ? 'θ (degrees)' : 'θ (radians)';
      document.getElementById('inputThetaDeg').style.display = isDeg  ? '' : 'none';
      document.getElementById('inputThetaRad').style.display = !isDeg ? '' : 'none';
      document.getElementById('pi-buttons').style.display    = !isDeg ? '' : 'none';

      drawGrid();
    }

    // ── π Quick-Select ──
    function setPi(expr) {
      document.getElementById('inputThetaRad').value = expr;
    }

    // ── Parse θ input (supports "pi", "π", "3pi/4", "2π/3", plain numbers) ──
    function parseThetaRad(raw) {
      // Normalize: replace π symbol (and variants), strip spaces, lowercase
      const s = raw.trim()
        .replace(/[πΠ]/g, 'pi')
        .replace(/\s+/g, '')
        .toLowerCase();

      // Match pattern: [-] [coeff] [*] pi [/ denom]
      // Handles: pi, pi/4, 2pi, 3pi/4, -pi/2, 2*pi/3, etc.
      const m = s.match(/^(-?)(\d*\.?\d*)\*?pi(\/(\d+\.?\d*))?$/);
      if (m) {
        const sign  = m[1] === '-' ? -1 : 1;
        const coeff = m[2] !== '' ? parseFloat(m[2]) : 1;
        const denom = m[4] !== undefined ? parseFloat(m[4]) : 1;
        if (denom === 0 || isNaN(coeff) || isNaN(denom)) return NaN;
        return sign * coeff * Math.PI / denom;
      }

      // Fall back to plain number (e.g. "1.5708")
      const num = parseFloat(s);
      return isNaN(num) ? NaN : num;
    }

    // Format a radian value as a readable π fraction (best effort)
    function formatRad(val) {
      const fractions = [
        [1,6,'π/6'], [1,4,'π/4'], [1,3,'π/3'], [1,2,'π/2'],
        [2,3,'2π/3'], [3,4,'3π/4'], [1,1,'π'],
        [5,4,'5π/4'], [3,2,'3π/2'], [7,4,'7π/4'], [2,1,'2π']
      ];
      for (const [n, d, label] of fractions) {
        if (Math.abs(val - (n * Math.PI / d)) < 0.0001) return label;
      }
      return val.toFixed(4) + ' rad';
    }

    // ── Draw Polar Grid ──
    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#dde3f0';
      ctx.lineWidth = 1;

      // Concentric circles
      for (let i = 1; i <= rings; i++) {
        ctx.beginPath();
        ctx.arc(cx, cy, i * scale, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.fillStyle = '#aab';
        ctx.font = '10px Arial';
        ctx.textAlign = 'left';
        ctx.textBaseline = 'alphabetic';
        ctx.fillText(i, cx + i * scale + 3, cy - 3);
      }

      // Angle lines & labels every 30°
      for (let deg = 0; deg < 360; deg += 30) {
        const rad = deg * Math.PI / 180;
        ctx.strokeStyle = '#dde3f0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(cx, cy);
        ctx.lineTo(cx + Math.cos(rad) * rings * scale, cy - Math.sin(rad) * rings * scale);
        ctx.stroke();

        const lx = cx + Math.cos(rad) * (rings * scale + 18);
        const ly = cy - Math.sin(rad) * (rings * scale + 18);
        ctx.fillStyle = '#99a';
        ctx.font = '9px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = currentMode === 'rad' ? radLabels[deg] : deg + '°';
        ctx.fillText(label, lx, ly);
      }

      // Axes
      ctx.strokeStyle = '#c0c8dd';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(canvas.width, cy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, canvas.height); ctx.stroke();
    }

    // ── Plot Point ──
    function plotPoint() {
      const r = parseFloat(document.getElementById('inputR').value);
      let thetaRad, thetaDisplay;

      if (currentMode === 'deg') {
        const deg = parseFloat(document.getElementById('inputThetaDeg').value);
        if (isNaN(deg)) { showError(); return; }
        thetaRad = deg * Math.PI / 180;
        thetaDisplay = deg + '°';
      } else {
        const raw = document.getElementById('inputThetaRad').value;
        thetaRad = parseThetaRad(raw);
        if (isNaN(thetaRad)) { showError(); return; }
        thetaDisplay = raw.trim(); // show what user typed
      }

      if (isNaN(r)) { showError(); return; }

      const px    = cx + r * Math.cos(thetaRad) * scale;
      const py    = cy - r * Math.sin(thetaRad) * scale;
      const rectX = (r * Math.cos(thetaRad)).toFixed(4);
      const rectY = (r * Math.sin(thetaRad)).toFixed(4);
      const degEquiv = ((thetaRad * 180 / Math.PI) % 360).toFixed(2);
      const radEquiv = formatRad(((thetaRad % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI));

      drawGrid();

      // Dashed line from origin to point
      ctx.strokeStyle = '#2ec4b6';
      ctx.lineWidth = 2;
      ctx.setLineDash([5, 4]);
      ctx.beginPath();
      ctx.moveTo(cx, cy);
      ctx.lineTo(px, py);
      ctx.stroke();
      ctx.setLineDash([]);

      // Angle arc
      ctx.strokeStyle = '#ffb703';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(cx, cy, 22, 0, -thetaRad, thetaRad < 0);
      ctx.stroke();

      // Point dot
      ctx.fillStyle = '#1a2744';
      ctx.beginPath();
      ctx.arc(px, py, 6, 0, 2 * Math.PI);
      ctx.fill();

      // Point label
      ctx.fillStyle = '#1a2744';
      ctx.font = 'bold 11px Georgia';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      ctx.fillText(`(${r}, ${thetaDisplay})`, px + 9, py - 4);

      // Result box
      const bothAngles = currentMode === 'deg'
        ? `also = <strong>${radEquiv}</strong>`
        : `also = <strong>${degEquiv}°</strong>`;

      document.getElementById('resultBox').innerHTML =
        `Polar: <strong>(${r}, ${thetaDisplay})</strong> &nbsp;(${bothAngles})<br>` +
        `x = ${r} · cos(${thetaDisplay}) = <strong>${rectX}</strong><br>` +
        `y = ${r} · sin(${thetaDisplay}) = <strong>${rectY}</strong><br>` +
        `Rectangular: <strong>(${rectX}, ${rectY})</strong>`;
    }

    function showError() {
      document.getElementById('resultBox').textContent = 'Please enter valid numbers. In RAD mode, try "pi/2" or "3pi/4".';
    }

    function toggleAnswer(id, btn) {
      const el = document.getElementById(id);
      if (el.style.display === 'block') {
        el.style.display = 'none';
        btn.textContent = 'Show Answer';
      } else {
        el.style.display = 'block';
        btn.textContent = 'Hide Answer';
      }
    }

    // ── Practice Problem Generator ──
    const NICE_ANGLES = [
      {d:0,   cos:'1',      sin:'0',      cv:1,                sv:0},
      {d:30,  cos:'√3/2',   sin:'1/2',    cv:Math.sqrt(3)/2,   sv:0.5},
      {d:45,  cos:'√2/2',   sin:'√2/2',   cv:Math.sqrt(2)/2,   sv:Math.sqrt(2)/2},
      {d:60,  cos:'1/2',    sin:'√3/2',   cv:0.5,              sv:Math.sqrt(3)/2},
      {d:90,  cos:'0',      sin:'1',      cv:0,                sv:1},
      {d:120, cos:'-1/2',   sin:'√3/2',   cv:-0.5,             sv:Math.sqrt(3)/2},
      {d:135, cos:'-√2/2',  sin:'√2/2',   cv:-Math.sqrt(2)/2,  sv:Math.sqrt(2)/2},
      {d:150, cos:'-√3/2',  sin:'1/2',    cv:-Math.sqrt(3)/2,  sv:0.5},
      {d:180, cos:'-1',     sin:'0',      cv:-1,               sv:0},
      {d:210, cos:'-√3/2',  sin:'-1/2',   cv:-Math.sqrt(3)/2,  sv:-0.5},
      {d:225, cos:'-√2/2',  sin:'-√2/2',  cv:-Math.sqrt(2)/2,  sv:-Math.sqrt(2)/2},
      {d:240, cos:'-1/2',   sin:'-√3/2',  cv:-0.5,             sv:-Math.sqrt(3)/2},
      {d:270, cos:'0',      sin:'-1',     cv:0,                sv:-1},
      {d:300, cos:'1/2',    sin:'-√3/2',  cv:0.5,              sv:-Math.sqrt(3)/2},
      {d:315, cos:'√2/2',   sin:'-√2/2',  cv:Math.sqrt(2)/2,   sv:-Math.sqrt(2)/2},
      {d:330, cos:'√3/2',   sin:'-1/2',   cv:Math.sqrt(3)/2,   sv:-0.5},
    ];

    let generatedCount = 0;
    const MAX_GEN = 10;
    let genId = 0;

    function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

    function fmtVal(v) {
      const r = Math.round(v * 1000) / 1000;
      return Number.isInteger(r) ? String(r) : r.toFixed(3);
    }

    // Format one multiplication step: "r · (exact) = result"
    function fmtStep(r, exact, val) {
      const product = r * val;
      const clean = Math.abs(product - Math.round(product)) < 0.0001;
      if (exact === '0')  return `${r} · 0 = <strong>0</strong>`;
      if (exact === '1')  return `${r} · 1 = <strong>${r}</strong>`;
      if (exact === '-1') return `${r} · (−1) = <strong>${-r}</strong>`;
      const pStr = clean ? String(Math.round(product)) : product.toFixed(3);
      return `${r} · (${exact}) ${clean ? '=' : '≈'} <strong>${pStr}</strong>`;
    }

    function buildProblem(qNum, question, answerHTML) {
      const id = `gp${++genId}`;
      return `
        <div class="practice-problem">
          <p class="q-label">Problem ${qNum}</p>
          <p>${question}</p>
          <button class="show-answer-btn" onclick="toggleAnswer('${id}', this)">Show Answer</button>
          <div class="answer-reveal" id="${id}">${answerHTML}</div>
        </div>`;
    }

    // Type A: Polar → Rectangular
    function genPolarToRect(qNum) {
      const r = pick([1, 2, 3, 4, 5, 6]);
      const a = pick(NICE_ANGLES);
      const x = fmtVal(r * a.cv), y = fmtVal(r * a.sv);
      const q = `Convert to rectangular coordinates: <strong>(${r}, ${a.d}°)</strong>`;
      const ans =
        `Use <strong>x = r·cos(θ)</strong> and <strong>y = r·sin(θ)</strong> with r = ${r} and θ = ${a.d}°:<br><br>` +
        `x = ${fmtStep(r, a.cos, a.cv)}<br>` +
        `y = ${fmtStep(r, a.sin, a.sv)}<br><br>` +
        `<strong>Rectangular: (${x}, ${y})</strong>`;
      return buildProblem(qNum, q, ans);
    }

    // Type B: Rectangular → Polar (coords generated from known polar to keep answers clean)
    function genRectToPolar(qNum) {
      const r = pick([2, 3, 4, 5]);
      const a = pick(NICE_ANGLES.filter(a => a.d % 90 !== 0));
      const x = fmtVal(r * a.cv), y = fmtVal(r * a.sv);
      const atanRaw = Math.round(Math.atan(r * a.sv / (r * a.cv)) * 180 / Math.PI);

      let qLabel, adjustment;
      if (a.d < 90) {
        qLabel = `x > 0, y > 0 → <strong>Quadrant I</strong>. arctan is already correct — no adjustment needed.`;
        adjustment = `θ = <strong>${a.d}°</strong>`;
      } else if (a.d < 180) {
        qLabel = `x < 0, y > 0 → <strong>Quadrant II</strong>. arctan returns a negative angle (it "thinks" the point is in Q IV). Add 180° to correct it.`;
        adjustment = `θ = ${atanRaw}° + 180° = <strong>${a.d}°</strong>`;
      } else if (a.d < 270) {
        qLabel = `x < 0, y < 0 → <strong>Quadrant III</strong>. arctan returns a Q I angle (positive, but too small). Add 180° to correct it.`;
        adjustment = `θ = ${atanRaw}° + 180° = <strong>${a.d}°</strong>`;
      } else {
        qLabel = `x > 0, y < 0 → <strong>Quadrant IV</strong>. arctan returns a negative angle. Add 360° to get a positive angle in range.`;
        adjustment = `θ = ${atanRaw}° + 360° = <strong>${a.d}°</strong>`;
      }

      const q = `Convert to polar coordinates: <strong>(${x}, ${y})</strong>`;
      const ans =
        `<strong>Step 1 — Find r</strong> using r = √(x² + y²):<br>` +
        `r = √(${x}² + ${y}²) = √${r*r} = <strong>${r}</strong><br><br>` +
        `<strong>Step 2 — Find θ</strong> using arctan(y/x):<br>` +
        `arctan(${y} / ${x}) = ${atanRaw}°<br><br>` +
        `<strong>Step 3 — Quadrant check</strong> (arctan only returns −90° to 90°, so always verify):<br>` +
        `${qLabel}<br>` +
        `${adjustment}<br><br>` +
        `<strong>Polar: (${r}, ${a.d}°)</strong>`;
      return buildProblem(qNum, q, ans);
    }

    // Type C: Alternate representations
    function genAltRep(qNum) {
      const r = pick([2, 3, 4, 5]);
      const a = pick(NICE_ANGLES);
      const alt2 = (a.d + 180) % 360;
      const q = `Give two other polar representations of <strong>(${r}, ${a.d}°)</strong> — one with positive r, one with negative r.`;
      const ans =
        `<strong>Rule 1 — Keep r positive, add 360°</strong> to θ:<br>` +
        `A full rotation brings you back to the exact same direction, so the point is identical.<br>` +
        `(${r}, ${a.d}° + 360°) = <strong>(${r}, ${a.d + 360}°)</strong><br><br>` +
        `<strong>Rule 2 — Negate r, add 180°</strong> to θ:<br>` +
        `Negating r makes you face the opposite direction. Adding 180° rotates you halfway around to compensate — you end up at the same point.<br>` +
        `(−${r}, ${a.d}° + 180°) = <strong>(−${r}, ${alt2}°)</strong><br><br>` +
        `All three name the exact same point in the plane.`;
      return buildProblem(qNum, q, ans);
    }

    function generateMore() {
      const batch = Math.min(5, MAX_GEN - generatedCount);
      if (batch <= 0) return;
      const types = ['polar', 'rect', 'alt'];
      const container = document.getElementById('generated-problems');
      for (let i = 0; i < batch; i++) {
        const qNum = 4 + generatedCount + i + 1;
        const type = pick(types);
        let html;
        if (type === 'polar')     html = genPolarToRect(qNum);
        else if (type === 'rect') html = genRectToPolar(qNum);
        else                      html = genAltRep(qNum);
        container.insertAdjacentHTML('beforeend', html);
      }
      generatedCount += batch;
      const btn     = document.getElementById('gen-btn');
      const counter = document.getElementById('gen-counter');
      if (generatedCount >= MAX_GEN) {
        btn.disabled = true;
        btn.textContent = '✓ All 10 extra problems generated';
        btn.style.cssText = 'background:#d1fae5; color:#065f46; cursor:default;';
        counter.textContent = '';
      } else {
        counter.textContent = `${generatedCount} of ${MAX_GEN} extra problems generated`;
      }
    }

    // Init
    drawGrid();
    plotPoint();
  </script>

</body>
</html>
